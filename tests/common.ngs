# This file should contain only product agnostic parts
# It is planned to be used across all relevant Beame.io products
ns {

	test

	# ---------- type Test - begin ----------
	type Test
	global init

	_exit_hook_lock = Lock()

	_id_lock = Lock()

	F setup(t:Test) {

		id = 1
		_id_lock.acquire({ t.id = "${time()}-${id}"; id += 1 })

		env_vars = [
			'BEAME_INTERNAL_AUTH_SERVER_FQDN'
			'BEAME_DEV_AUTH_FQDN'
		]
		for e in env_vars {
			assert(e in ENV, "Environment variable ${e} must be set")
		}
		
		while true {
			t.home = ENV.HOME / 'test-' + CHARS::ascii_lowercase.rand(4)
			not(Path(t.home)) breaks
		}
		t.beame_dir = t.home / '.beame'

		log("Test home directory is ${t.home}")
		$(mkdir ${t.home})

		_exit_hook_lock.acquire({
			exit_hook.push({
				if ENV.get('KEEP_TEST_DIR') {
					log("Keeping test directory ${t.home} as KEEP_TEST_DIR environment variable is set")
					return
				}
				# Safety check
				if not(t.home ~ /\/test-/) {
					error("Not removing test home directory is ${t.home}")
					return
				}
				log("Removing test home directory ${t.home}")
				$(rm -r ${t.home})
			})
		})
		t
	}

	global fqdn_dir
	F fqdn_dir(t:Test, fqdn) t.beame_dir / 'v2' / fqdn

	global copy_cred_to_store
	F copy_cred_to_store(t:Test, fqdn:Str, src:Str) {
		debug("test", "Copying dev credential fqdn ${fqdn} to store from ${src}")
		$(mkdir -p ${t.beame_dir / 'v2'})
		$(cp -a $src ${t.fqdn_dir(fqdn)})
	}

	global copy_dev_cred_to_store
	F copy_dev_cred_to_store(t:Test) copy_cred_to_store(t, ENV.BEAME_DEV_AUTH_FQDN, "${ENV.HOME}/${ENV.BEAME_DEV_AUTH_FQDN}")

	global remove_dev_cred_from_store
	doc Removes Beame test requests signing credential from store
	F remove_dev_cred_from_store(t:Test) {
		$(rm -r ${t.fqdn_dir(ENV.BEAME_DEV_AUTH_FQDN)})
	}

	global create_token
	F create_token(cp:CommandsPipeline) {
		token = ``$cp``
		assert_string(token, "Token is a string")
		token
	}

	# ---------- type Test - end ----------

	EXPECTED_EXPORTED_FILE_EXTENSIONS = %[pem key chain.p7b pkcs12 pkcs12.pwd]

	F base64decode(s:Str) `echo $s | base64 -d 2>${true}`

	doc Checks that process outputs specific text and exists with non-zero code
	F should_fail_with_text(cp:CommandsPipeline, text:Str) {
		try {
			$($cp)
			throw TestFail('Exited with code 0')
		} catch(e:ProcessFail) {
			text not in e.process.stdout throws TestFail("No expected text in output")
			return 'Expected text found'
		}
	}

	F run(tests_sets:Hash, tests:Arr) {

		all_tests = tests_sets.keys().reject(/^_/)

		if not(tests) {
			die("Please specify --tests. Either 'all' or one or more of: ${all_tests.join(',')} (comma separated)")
		}

		tests_to_run = []
		for arg in tests {
			econd {
				arg == 'all' {
					tests_to_run += all_tests
				}
				m = arg ~ /^[-](.+)$/ {
					m[1] not in all_tests throws InvalidArgument("Unknown tests set ${m[1]}. Run without arguments to see tests sets.")
					tests_to_run -= [m[1]]
					
				}
				true {
					arg not in all_tests throws InvalidArgument("Unknown tests set ${arg}. Run without arguments to see tests sets.")
					tests_to_run += [arg]
				}
			}
		}

		r = TestsResults()
		threads_results = null

		status_display = Thread({
			$(sleep 1)
			prev = {'rows': null}
			need_newline = false
			while not(threads_results) {
				try {
					x = Table("Tests progress, ${Time()}", r)
					if x.rows == prev.rows {
						1.write('.')
						need_newline = true
					} else {
						if need_newline {
							echo("")
							need_newline = false
						}
						echo(x)
					}
					prev = x
				} catch(e:Exception) {
					print_exception(e)

				}
				$(sleep 2)
			}
			if need_newline {
				echo("")
			}
		})

		global_test = test
		threads_results = tests_to_run.pmap(F(test_to_run) {
			F test(name:Str, cb:Fun) global_test(r, test_to_run, name, cb)
			tests_sets[test_to_run](r, Test().setup(), test)
		})

		e = status_display.join()
		if e is Exception {
			print_exception(e)
		}

		exit_code = 0
		threads_results.each_idx_val(F(idx, e) {
			if e is Exception {
				error("-------------------- [THREAD] Exception in test set '${tests_to_run[idx]}' --------------------")
				print_exception(e)
				exit_code += 1
			}
		})

		results_table = Table("Tests final results, ${Time()}", r)

		stats = Stats()
		r.each_group_test(F(group, test, result) {
			# if result is Success {
			# 	echo("-------------------- Status in test ${group}/${test} --------------------")
			# 	x = result.get()
			# 	echo(x)
			# }
			if result is Failure {
				error("-------------------- Exception in test ${group}/${test} --------------------")
				print_exception(result.val)
				exit_code += 1
			}
			stats.push(result.typeof().name)
		})

		exit_hook.push({
			echo("")
			echo(results_table)
			echo("")
			if exit_code {
				echo("FAILURE")
			} else {
				echo("SUCCESS")
			}
		})

		min([100, exit_code])
	}
}
